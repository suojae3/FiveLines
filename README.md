
---


## 1장 리팩터링 리팩터링하기

1. 가장 단순한 형태의 리팩터링은 기능을 변경하지 않고 코드를 변경하는 것을 의미합니다.
   
```typescript
	//before
	return pow(base, exp / 2) * pow(base, exp / 2);
	
	//after
	let result = pow(base, exp / 2);
	return result * result;
```

2. 리팩터링을 해야하는 이유는 다음과 같습니다.
	- 코드를 더 빠르게 만들기 위해 (위의 예시)
	- 더 작은 코드를 만들기 위해
	- 코드를 더 일반적이거나 재사용 가능하기 위해
	- 가독성을 높이고 유지보수의 용이성을 위해

3. **따라서 리팩토링의 이유는 순전히 경제성에 관한 것입니다**

4. 함수는 한가지 작업을 수행해야합니다. 이를 어기는 함수를 발견할 수 있는 코드스멜에 대한 민감성을 갖추어야 합니다.

5. 프로그래밍 작업으로 문제해결시 사용하는 6단계 작업절차를 권장합니다
	- **탐색**: 고객 자신도 무엇을 만들지 모르는 경우가 많습니다. 구현가능성도 점치기 어렵습니다. 이럴 땐 항상 실험부터 시작합니다.
	- **명세화**: 무엇을 만들지 알게되면 명세화합니다. 최적의 경우 이는 자동화 테스트 형태가 됩니다.
	- **구현**: 코드를 구현합니다.
	- **테스트**: 코드가 명세화를 따르는지 확인합니다.
	- **리팩토링**: 코드를 전달전 다음사람이 쉽게 읽을 수 있는지 확인합니다.
	- **전달**: PR과 같은 방법으로 전달합니다.

6. 새로운 것을 구현할 때마다 새 코드를 쉽게 추가할 수 있게 리팩터링을 먼저합니다.

7. 리팩터링을 하지 말아야 하는 코드는 다음과 같습니다
	- 한 번 실행하고 삭제할 코드
	- 폐기되기 전 유지보수 모드의 코드
	- 임베디드 시스템, 게임 고급 물리엔진 등 엄격한 성능 요구사항이 있는 코드

8. 소프트웨어 개발에서 자동화된 테스트는 자동차 브레이크와 같습니다. 자동화 테스트를 수행하면 안심하고 빠르게 진행할 수 있습니다.


---
---
## 2장 리팩터링 깊게 들여다보기

1. 특정 부분을 수정하면 다른 곳에서 문제가 발생하는 시스템을 취약하다고 말합니다. 이 취약성의 근원은 일반적으로 **전역상태입니다**.

2. 변수를 명시적으로 체크해서 불변속성을 제거함으로써 유지보수성을 향상시킬 수 있습니다. 

3. 함께 변하는 것은 함께 있어야합니다. 이를 **불변속성의 범위제한(localizing invariants)** 라고 합니다.

4. **상속보다는 컴포지션을 사용해야합니다**. 대부분의 리팩토링 패턴과 규칙은 구체적으로 객체 컴포지션을 돕기 위한 것입니다.

5. **컴포지션의 가장 큰 장점은 수정이 아닌 추가로 변경이 가능하다는 것입니다.** 이러한 속성을 **개방-폐쇄 원칙**이라고 합니다. 소프트웨어 구성 요소들은 확장에 대해 열려있어야하고, 수정에 대해 닫혀있어야합니다.

6. 어떤 코드가 사용되고 어떤 코드가 사용되지 않는지 주의를 기울이고 사용하지 않는 코드는 최대한 빠르게 삭제합니다.

7. 소프트웨어는 실생활의 특정 측면을 모델링한 것입니다. 즉 소프트웨어와 대응되는 실세계는 항상 존재합니다. 이러한 실세계의 구성요소를 소프트웨어의 **도메인** 이라고 합니다.

---
---

## 3장 긴 코드 조각 내기

1. 메서드는 { 와 } 를 제외하고 5줄 이상이 되어서는 안됩니다.

2. 20줄의 메서드가 있을 경우 첫 10줄과 10줄로 각각 도우미 메서드를 만듭니다.

3. 메서드가 길다는 것 자체가 스멜입니다. 각각 5줄의 코드가 있는 4개의 메서드가 20줄인 하나의 메서드보다 훨씬 빠르고 이해하기 쉽습니다.

4. 
